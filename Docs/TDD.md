# TDD

## √çndice T√©cnico (TDD)

### 1. Arquitectura General del Proyecto

- 1.1 Versi√≥n y configuraci√≥n de Unity
- 1.2 Render Pipeline: elecci√≥n y justificaci√≥n
- 1.3 Estructura general de escenas
- 1.4 Modularidad y separaci√≥n por sistemas
- 1.5 Arquitectura ECS con Unity DOTS
- 1.6 Integraci√≥n con Netcode for GameObjects

### 2. Control del Jugador y C√°mara

- 2.1 Movimiento y control del h√©roe (TPS)
- 2.2 Control de c√°mara seg√∫n estado del h√©roe
- 2.3 Comandos a escuadras (hotkeys, UI, radial)
- 2.4 Feedback visual y navegaci√≥n(x)
- 2.5 Modo espectador tras muerte(x)

### 3. IA de Escuadras y Unidades

- 3.1 Sistema de navegaci√≥n (NavMesh)
- 3.2 Comportamiento en formaci√≥n reactivo
- 3.3 IA de escuadra grupal vs individual
- 3.4 Coordinaci√≥n de habilidades de escuadra
- 3.5 FSM para estados de escuadras y transici√≥n a retirada

### 4. Construcci√≥n de Mapas y Escenarios

- 4.1 Herramientas para creaci√≥n de mapas (Unity Terrain / externos)
- 4.2 Implementaci√≥n de elementos destructibles (puertas, obst√°culos)
- 4.3 Sistema de zonas y triggers f√≠sicos (Supply, captura, visibilidad)
- 4.4 Configuraci√≥n del mapa MVP y puntos claves

### 5. Sistema de Combate y Da√±o

- 5.1 Combate del h√©roe (colliders y animaciones)
- 5.2 Combate de escuadras (detecci√≥n y ataques sincronizados)
- 5.3 Tipos de da√±o y resistencias (blunt, slashing, piercing)
- 5.4 C√°lculo de da√±o y penetraci√≥n en C#
- 5.5 Gesti√≥n de cooldowns y tiempos de habilidad

### 6. Flujo de Partida

- 6.1 Transiciones entre escenas (Feudo ‚Üí Preparaci√≥n ‚Üí Combate ‚Üí Post)
- 6.2 Ciclo de vida del h√©roe (muerte, respawn, cooldown)
- 6.3 Estado y retirada de escuadra al morir el h√©roe
- 6.4 Reglas del sistema de captura y uso de supply points
- 6.5 Asignaci√≥n de spawn inicial

### 7. Progresi√≥n y Guardado de Datos

- 7.1 Progresi√≥n del h√©roe (nivel, atributos, perks)
- 7.2 Guardado local en MVP
- 7.3 Estructura de ScriptableObjects para perks y escuadras
- 7.4 Sistema de perks: carga, activaci√≥n y visualizaci√≥n

### 8. Multijugador (MVP)

- 8.1 Arquitectura de red: servidor dedicado
- 8.2 Sincronizaci√≥n de escuadras y h√©roes (Snapshots o comandos, decisi√≥n final)
- 8.3 Interpolaci√≥n de movimiento y predicci√≥n
- 8.4 Comunicaci√≥n entre jugadores (chat b√°sico)
- 8.5 Cambios de escuadra desde supply points (restricciones de sincronizaci√≥n)

### 9. UI y HUD

- 9.1 Sistema de UI (Canvas con Unity UI)
- 9.2 HUD de batalla: salud, habilidades, escuadra, √≥rdenes
- 9.3 Minimapa din√°mico (feudo y combate)
- 9.4 Interfaz de preparaci√≥n y loadouts
- 9.5 Men√∫s de interacci√≥n con supply y puntos de captura

### 10. Seguridad y Backend (Para expansi√≥n futura)

- 10.1 Estado actual (solo local)
- 10.2 Recomendaciones para transici√≥n a backend (login, matchmaking, almacenamiento)
- 10.3 Gesti√≥n segura de progresi√≥n futura

### 11. Extras T√©cnicos

- 11.1 Sistema de liderazgo (restricciones en loadouts)
- 11.2 Sistema de estamina y gasto por acci√≥n
- 11.3 Visualizaci√≥n de formaciones y selecci√≥n de unidades
- 11.4 Optimizaci√≥n de escena y assets (nivel MVP)

### 12. Glosario tecnico

---

## 1. üß± Arquitectura General del Proyecto

### 1.1 Motor y Versi√≥n

- **Motor:** Unity
- **Versi√≥n:** Unity 2022.3.6f1 (LTS)

### 1.2 Render Pipeline

- **Pipeline:** URP (Universal Render Pipeline)
- **Justificaci√≥n:**
    - Buen balance entre rendimiento y calidad visual.
    - Ideal para entornos con escuadras numerosas.
    - Compatible con dispositivos de gama media.

### 1.3 Arquitectura T√©cnica

- **Paradigma Base:** ECS (Entity Component System)
- **Implementaci√≥n:** Unity Entities 1.0 (DOTS)
- **Justificaci√≥n:**
    - Escalabilidad con m√∫ltiples unidades en pantalla.
    - Separaci√≥n clara entre l√≥gica y datos.
    - Rendimiento optimizado para combate en masa.

### 1.4 Organizaci√≥n Modular por Escenas

- El proyecto se divide en **m√∫ltiples escenas funcionales**:
    - **Login / Selecci√≥n de personaje**
    - **Feudo (hub social)**
    - **Barrac√≥n (gesti√≥n de escuadras)**
    - **Preparaci√≥n de batalla**
    - **Mapa de batalla**
    - **Post-partida**

> Cada escena tiene su propio sistema de UI, l√≥gica de flujo y referencia a sistemas compartidos.
> 

### 1.5 Networking

- **Soluci√≥n de red:** Unity Netcode for GameObjects (con ECS wrapper donde sea necesario).
- **Topolog√≠a:** Cliente-servidor con servidor dedicado.
- **Estado sincronizado:**
    - Posici√≥n y estado de h√©roes.
    - Posici√≥n, formaciones y acciones de escuadras.
    - Eventos de combate y habilidades.
- **Autoridad:** Cliente predice, servidor valida.
- **Interpolaci√≥n:** Movimiento interpolado con buffers de posici√≥n para h√©roes y escuadras.

---

## üéÆ Secci√≥n 2: Control del Jugador y C√°mara

---

### üéÆ 2.1 Control del H√©roe

### üéØ Descripci√≥n General:

El jugador controla directamente al **h√©roe** en tercera persona durante la batalla. El movimiento, ataques y uso de habilidades son de estilo **action-RPG t√°ctico**, similar a *Conqueror‚Äôs Blade*.

### üß© Componentes Principales:

- `HeroControllerSystem` (SystemBase):
    - Sistema de movimiento basado en **EntityCommandBuffer** y **Input System**.
    - Controla desplazamiento (`WASD`), salto (`Space`), sprint (`LeftShift`), y bloqueo de movimiento si est√° aturdido o muerto.
    - Referencia el componente `HeroStats` para consultar la estamina, velocidad, etc.
- `HeroInputComponent` (IComponentData):
    - Contiene inputs actuales del frame: movimiento, ataque, habilidades, √≥rdenes, etc.
- `HeroStatsComponent` (IComponentData):
    - Velocidad base, fuerza, estamina, cooldowns, vitalidad, etc.
- `HeroAnimationControllerAuthoring` (baker + animation state data):
    - Maneja las transiciones entre animaciones (Idle, Run, Attack, Stunned).
    - Usa par√°metros de estado recibidos desde el `HeroControllerSystem`.
- `StaminaSystem`:
    - Gestiona el gasto y recuperaci√≥n de estamina.
    - Valida si un input puede ejecutarse seg√∫n el estado del h√©roe.

### ‚öôÔ∏è L√≥gica de funcionamiento:

- El input se captura desde `Unity.InputSystem`.
- Se convierte en un `HeroInputComponent` al que los sistemas acceden.
- Las acciones (mover, atacar, usar habilidades) son evaluadas por distintos sistemas (`MovementSystem`, `SkillSystem`, `StaminaSystem`).
- Si el h√©roe muere, se desactiva el control local y se activa el modo c√°mara espectador (ver 2.2).

---

### üé• 2.2 C√°mara

### üìå Normal:

- **Tipo:** Tercera persona con seguimiento.
- **Movimiento:**
    - Rotaci√≥n libre (ejes X/Y).
    - Zoom con scroll limitado entre dos distancias fijas.
- **Colisi√≥n de c√°mara:** Evita que la c√°mara atraviese paredes u objetos grandes.
- **Opcional:** Tecla para modo t√°ctica ligera (eleva el √°ngulo y aleja la c√°mara).

### üß© Componentes:

- `HeroCameraFollowSystem`:
    - Ajusta posici√≥n y rotaci√≥n suavemente (Lerp).
    - Controla zoom, orientaci√≥n y modo t√°ctica.
- `CameraSettingsComponent`:
    - Datos: distancia, altura, sensibilidad, suavizado, l√≠mite de zoom.
- `CameraStateComponent`:
    - Flags: modoNormal / modoT√°ctico / modoEspectador.
- `CameraCollisionSystem`:
    - Detecta colisiones para ajustar la posici√≥n y evitar clipping.

### üßü Modo Espectador (al morir):

- Se activa cuando el h√©roe entra en estado `KO` o `Muerte`.
- Permite cambiar entre aliados vivos (`‚Üê / ‚Üí` o `Tab`).
- Desactiva HUD activo y reemplaza por un modo espectador m√≠nimo.
- Retorna al h√©roe al final del cooldown autom√°ticamente.

---

### üõ°Ô∏è 2.3 Control de Escuadras

### üìå Descripci√≥n:

El jugador controla **una escuadra activa** a la vez. Puede darle √≥rdenes y cambiar formaciones. Todo se hace mediante **hotkeys**, **UI de escuadra**, o **clics contextuales**.

### üß© Componentes T√©cnicos:

- `SquadControlSystem`:
    - Toma inputs y aplica √≥rdenes a la escuadra activa.
    - Comunica con `FormationSystem`, `OrderSystem`, `SkillSystem`.
- `SquadInputComponent`:
    - Contiene flags: orden actual, tipo de orden, formaci√≥n activa.
- `SquadStateComponent`:
    - Datos de la escuadra: posici√≥n, formaci√≥n actual, cooldowns, estado de unidad (alerta, en combate, flanqueado, etc.).
- `FormationSystem`:
    - Ajusta la colocaci√≥n de unidades dentro de la escuadra seg√∫n la formaci√≥n seleccionada.
- `SquadOrderSystem`:
    - Ejecuta las √≥rdenes dadas por el jugador:
        - `C`: seguir al h√©roe
        - `X`: mantener posici√≥n
        - `V`: atacar
    - Tambi√©n se puede activar un **men√∫ radial con ALT** o emitir √≥rdenes con **click derecho en terreno** (raycast desde la c√°mara).

### üß† Formaciones Soportadas:

- L√≠nea (`F1`)
- Dispersa (`F2`)
- Testudo (`F3`)
- Cu√±a (`F4`), seg√∫n escuadra

Cada formaci√≥n est√° representada en ECS como una `NativeArray<LocalPosition>` relativa al l√≠der de escuadra.

### üß© UI de Escuadra Activa:

- Sistema basado en Unity UI (Canvas) que muestra:
    - Icono de la escuadra
    - Formaci√≥n actual
    - Botones para habilidades (1, 2, 3...)
    - Indicadores visuales del estado (vida, cooldowns, etc.)
- Interact√∫a con `SquadSelectionSystem` para cambiar entre escuadras fuera de combate (en supply points).

### üîÑ Interacci√≥n entre sistemas:

- `HeroControllerSystem` ‚Üî `SquadControlSystem`:
    - El h√©roe da la orden, la escuadra reacciona seg√∫n estado.
- `FormationSystem` ‚Üî `SquadAIController`:
    - Una vez recibida una orden, las unidades se reacomodan seg√∫n la formaci√≥n activa.
- `SkillSystem`:
    - Escuadra puede ejecutar habilidades activas propias (en base a cooldown y trigger manual).

---

ü§ñ 3. IA de Escuadras y Unidades

---

üß≠ 3.1 Sistema de Navegaci√≥n (NavMesh)

üìå Descripci√≥n:

Las escuadras se mueven utilizando NavMesh con un agente maestro (pivot) que lidera la formaci√≥n. Las unidades individuales se posicionan relativamente a ese pivot siguiendo una l√≥gica de patr√≥n de formaci√≥n.

üß© Componentes:

NavMeshAgentAuthoring (GameObject conversion)

SquadNavigationComponent (IComponentData)

targetPosition: destino global

isMoving: bool

formationOffset[]: offsets locales para cada unidad

üîß Sistemas:

SquadNavigationSystem:

Calcula el path principal del pivot.

Distribuye posiciones a cada unidad de escuadra seg√∫n formationOffset.

UnitFollowFormationSystem:

Mueve cada unidad hacia su LocalToWorld esperado.

Interpola o reubica para mantener la cohesi√≥n.

SquadObstacleAvoidanceSystem:

Detecta obst√°culos en el camino y ajusta temporalmente la forma.

---

### üß± 3.2 Comportamiento Reactivo en Formaci√≥n

### üìå Descripci√≥n:

Las escuadras **reaccionan din√°micamente** al entorno manteniendo su formaci√≥n mientras maniobran. Adaptan posiciones en pasajes estrechos, evitan colisiones y mantienen la unidad visual.

### üß© Componentes:

- `EnvironmentAwarenessComponent`:
    - Define rango de detecci√≥n y tipo de entorno (estrecho, abierto, escaleras, etc.).
- `FormationAdaptationSystem`:
    - Cambia din√°micamente la formaci√≥n seg√∫n:
        - Tama√±o del terreno
        - Obst√°culos (muros, enemigos)
        - Tipo de formaci√≥n permitida
- `UnitSpacingSystem`:
    - Ajusta la separaci√≥n entre unidades.
    - Evita solapamiento, especialmente en combate.

---

### üë• 3.3 IA de Escuadra Grupal vs Individual

### üìå Descripci√≥n:

El comportamiento es **grupal**, pero con **unidad m√≠nima de decisi√≥n** en cada soldado (solo para microacciones: evasi√≥n, rotaci√≥n, targeting).

### üß© Componentes:

- `SquadAIComponent`:
    - `state`: enum general (Idle, Atacando, Reagrupando, Defendiendo, Retirada)
    - `targetEntity`: enemigo actual
    - `isInCombat`: bool
- `UnitCombatComponent`:
    - Posici√≥n relativa
    - `attackCooldown`
    - Estado local (cubierto, flanqueado, suprimido)

### üß© Sistemas:

- `SquadAISystem`:
    - L√≥gica de toma de decisiones grupal
    - Inicia combate si enemigo dentro de rango
    - Cambia formaci√≥n si est√° siendo flanqueado
- `UnitTargetingSystem`:
    - Asigna enemigo cercano a cada unidad
    - Maneja ‚Äúsobretargeting‚Äù (m√°s de 3 soldados contra 1 objetivo = redistribuci√≥n)
- `UnitAttackSystem`:
    - Verifica cooldowns
    - Ejecuta animaciones de ataque si tiene target
    - Usa `criticalChance` del arma para aplicar golpes cr√≠ticos de 1.5x

---

### üß† 3.4 Coordinaci√≥n de Habilidades de Escuadra

### üìå Descripci√≥n:

Habilidades de escuadra se ejecutan de forma **coordinada y sincronizada**, basadas en se√±ales del jugador (hotkey) y condiciones t√°cticas (posici√≥n, formaci√≥n, enemigos).

### üß© Componentes:

- `SquadSkillComponent`:
    - `cooldowns[]`
    - `triggerFlags[]` (true cuando se presiona el bot√≥n)
    - `isExecuting`: bool
- `SkillExecutionSystem`:
    - Verifica condiciones t√°cticas (formaci√≥n, rango, vista de enemigo).
    - Activa la animaci√≥n grupal (v√≠a trigger ECS ‚Üí Animator).
    - Env√≠a evento de red si es multijugador.
- `FormationConstraintSystem`:
    - Algunas habilidades solo se ejecutan en formaciones concretas (ej. Muro de Escudos).
    - Si no est√° en la formaci√≥n correcta, no puede activarse.

---

### üîÅ 3.5 FSM para Estados de Escuadras y Transici√≥n a Retirada

### üìå Descripci√≥n:

Cada escuadra tiene un sistema FSM (Finite State Machine) que rige su **estado actual** y transiciones. Esto es clave para el combate, la retirada, reubicaci√≥n y respuesta t√°ctica.

### üß© Estados:

- `Idle`: sin orden activa
- `Moving`: reposicion√°ndose
- `InCombat`: cuerpo a cuerpo o ataque a distancia
- `HoldingPosition`: est√°tica y en formaci√≥n
- `Retreating`: en retirada hacia punto seguro
- `KO`: destruida (si pierde todas sus unidades)

### üß© Componentes:

- `SquadStateComponent`:
    - `currentState`: enum
    - `timer`: duraci√≥n del estado
    - `transitionTo`: pr√≥ximo estado deseado
- `SquadFSMSystem`:
    - Controla transiciones l√≥gicas:
        - Si el h√©roe muere ‚Üí `HoldingPosition`
        - Si recibe da√±o masivo ‚Üí `Retreating`
        - Si est√° a salvo ‚Üí `Idle`
- `RetreatLogicSystem`:
    - Calcula ruta de retirada (alej√°ndose de enemigos).
    - Emite evento para desaparici√≥n si llega a zona segura.

## üèóÔ∏è 4. Construcci√≥n de Mapas y Escenarios

---

### üõ†Ô∏è 4.1 Herramientas para Creaci√≥n de Mapas

### üìå Descripci√≥n:

El mapa MVP ser√° creado **a mano en Unity** utilizando herramientas internas de terreno y modelado modular (prefabs). Elementos como murallas, puertas, torres y obst√°culos se integran como objetos con colliders y tags espec√≠ficos.

### üß© Herramientas / Sistemas:

- **Unity Terrain Tools** para topograf√≠a b√°sica.
- Prefabs de murallas, edificios, escaleras y rampas.
- Sistema de etiquetas y layers para detecci√≥n de interacci√≥n (`LayerMask` personalizado: Terreno, Obst√°culo, SupplyPoint, Capturable, etc.).
- Dise√±o modular en `Grid Snapping` para facilitar pruebas.

### üß© C√≥digo:

- `MapAuthoringComponent` (GameObject ‚Üí Entity):
    - `zoneType`: enum (Default, Capturable, Supply, Respawn)
    - `isInteractable`: bool
- `TerrainTagSystem`:
    - Marca din√°micamente elementos importantes durante carga de mapa.
    - Se integra con pathfinding y FSM de escuadras para l√≥gica de evasi√≥n o captura.

---

### üö™ 4.2 Implementaci√≥n de Elementos Destructibles

### üìå Descripci√≥n:

Puertas y obst√°culos espec√≠ficos pueden **ser destruidos** por escuadras o maquinaria de asedio. Utilizan animaciones sincronizadas (no f√≠sicas) para representar destrucci√≥n.

### üß© Componentes:

- `DestructibleComponent`:
    - `hp`: puntos de vida
    - `isDestructible`: bool
    - `onDestroyedAnimation`: referencia a animaci√≥n
- `SiegeInteractComponent`:
    - `type`: enum (Ariete, Torre, etc.)
    - `interactableBySquad`: bool
    - `progress`: float (progreso de empuje / interacci√≥n)

### üîß Sistemas:

- `DamageToStructureSystem`:
    - Aplicaci√≥n de da√±o por habilidades o ataques pesados.
    - Destruye estructura y lanza animaci√≥n si `hp <= 0`.
- `SiegePushSystem`:
    - Escuadras designadas "empujan" arietes/torres cuando se les ordena.
    - Se mueve el objeto por ruta spline o puntos clave hasta destino.

---

### üì¶ 4.3 Sistema de Zonas y Triggers F√≠sicos

### üìå Descripci√≥n:

El mapa est√° lleno de **zonas funcionales**, cada una identificada por **colliders con triggers**, etiquetas y l√≥gica conectada al gameplay:

- Puntos de captura
- Zonas de suministro
- √Åreas de visibilidad extendida (torres)
- Spawn points

### üß© Componentes:

- `ZoneTriggerComponent`:
    - `zoneType`: enum (CapturePoint, SupplyPoint, VisionArea, Spawn)
    - `teamOwner`: int (0 = neutral, 1 = azul, 2 = rojo)
    - `radius`: float
- `ZoneInteractionSystem`:
    - Detecta si entidades (h√©roes o escuadras) entran en rango.
    - Lanza l√≥gica seg√∫n el tipo de zona:
        - `CapturePoint`: inicia barra de captura.
        - `SupplyPoint`: permite curar o cambiar escuadra si no est√° en disputa.
        - `Spawn`: determina ubicaci√≥n inicial del h√©roe.
- `CapturePointProgressComponent`:
    - `captureProgress`: float
    - `isContested`: bool
    - `heroesInZone`: buffer de Entity
- `SupplyInteractionSystem`:
    - Verifica si el punto no est√° en disputa.
    - Permite al jugador reconfigurar su escuadra activa (si tiene otras vivas).

### üß© Visual:

- C√≠rculos en el terreno para visualizar radio de acci√≥n.
- Cambian color seg√∫n propiedad (neutral, aliado, enemigo).

---

### üó∫Ô∏è 4.4 Configuraci√≥n del Mapa MVP y Puntos Claves

### üìå Descripci√≥n:

El MVP incluye **un √∫nico mapa sim√©trico asim√©trico**, con elementos espec√≠ficos:

- 2 puntos de spawn (por bando)
- 2 supply points por lado
- 1 bandera principal de base
- 1 bandera de captura intermedia
- Obst√°culos estrat√©gicos, puntos de visi√≥n, zonas estrechas

### üß© Estructura:

```
plaintext
CopiarEditar
AZUL SPAWN     --[SUPPLY]--        [CAPTURE POINT A]        --[SUPPLY]--    ROJO SPAWN
                                ‚Üò               ‚Üô
                             [BASE FLAG]

```

### üì¶ Componentes del mapa:

- `CaptureFlagA`: zona intermedia
- `BaseFlag`: punto de victoria (solo desbloqueable si A fue capturado)
- `SupplyPoints` x4: zonas funcionales
- `SpawnPointComponent`:
    - `spawnTeam`: int
    - `position`: Vector3
    - `isSelected`: bool

### üìå C√≥digo:

- `MapSceneManager` (MonoBehaviour + Bootstrap):
    - Coloca zonas como entidades ECS al cargar la escena.
    - Inicializa estado de puntos, propietarios, colores, HUD de mapa.
    - Enlaza l√≥gica de transici√≥n entre escena de preparaci√≥n ‚Üí combate.
    
    ---
    
    ### üè≥Ô∏è 4.4.1 Puntos de Captura
    
    ### üìå Descripci√≥n:
    
    Los puntos de captura son zonas estrat√©gicas que deben ser conquistadas por el bando atacante para avanzar y ganar la partida. Su funcionamiento es diferente al de los supply points:
    
    - **Propiedad inicial:** Todos los puntos de captura pertenecen al bando defensor al inicio de la partida.
    - **Captura irreversible:** Una vez que un punto de captura es conquistado por el bando atacante, no puede ser recuperado por el bando defensor durante esa partida.
    - **Desbloqueo secuencial:** Algunos puntos de captura est√°n bloqueados al inicio y solo se pueden capturar si se ha conquistado previamente el punto anterior (precondici√≥n). Un punto bloqueado no puede ser capturado hasta que se desbloquee.
    - **Punto de base:** Si el atacante conquista el punto de base, la partida termina inmediatamente con la victoria del bando atacante.
    - **Progresi√≥n:** Al capturar un punto previo, se desbloquea el siguiente punto de captura en la secuencia, permitiendo el avance del equipo atacante.
    - **Diferencia con supply points:** A diferencia de los supply points, los puntos de captura no pueden cambiar de due√±o varias veces; su captura es definitiva para el resto de la partida.
    
    ### üß© Componentes:
    
    - `CaptureZoneComponent`:
        - `captureProgress`: float (0 a 100)
        - `isContested`: bool
        - `teamOwner`: int (0: neutral, 1/2: equipos)
        - `isBase`: bool
        - `isLocked`: bool (indica si el punto est√° bloqueado y no puede capturarse)
        - `unlockCondition`: referencia al punto previo que debe ser capturado
    - `CaptureZoneTriggerSystem`:
        - Detecta h√©roes dentro del radio
        - Actualiza captura si cumple condiciones (nadie del bando propietario presente y el punto est√° desbloqueado)
        - Al completarse la captura, si el punto desbloquea otro, lo activa
        - Si es un punto de base y es capturado, termina la partida
    - `CaptureProgressUISystem`:
        - Sincroniza HUD de progreso
        - Env√≠a eventos de captura completada
    
    ### üß© Interacci√≥n:
    
    - El HUD recibe cambios de color, √≠conos o tiempo.
    - El resultado de la captura puede desbloquear zonas (ej.: Base se desbloquea tras capturar A/B).
    - Los puntos de captura no pueden ser recuperados por el bando defensor una vez perdidos.
    - Los supply points pueden cambiar de due√±o varias veces durante la partida, pero los puntos de captura no.
    
    ---
    
    ### ü©∫ 4.4.2 Supply Points
    
    ### üìå Descripci√≥n:
    
    Zonas pasivas que permiten curar al h√©roe/squad y cambiar de escuadra si no est√°n en disputa.
    
    ### üß© Componentes:
    
    - `SupplyPointComponent`:
        - `teamOwner`: int
        - `isContested`: bool
        - `isAvailable`: bool (determinado por presencia de enemigos)
    - `SupplyInteractionComponent`:
        - Detecta entrada del jugador
        - Muestra UI de cambio o activa curaci√≥n
        - Env√≠o de acci√≥n: ‚ÄúRetirar escuadra‚Äù, ‚ÄúTraer escuadra 2‚Äù
    - `SquadSwapSystem`:
        - Verifica si se puede hacer el cambio
        - Elimina la escuadra actual, instancia la nueva si est√° disponible
        - Lanza `SquadChangeEvent` para sincronizar el nuevo estado
    
    ### üß© Curaci√≥n:
    
    - `HealingZoneSystem`:
        - Revisa que haya permanencia del h√©roe/squad dentro del collider por X tiempo
        - Incrementa vida por tick
        - Aplica solo si `isContested = false`
    
    ---
    
    ### üß≠ 4.4.3 Spawn Points
    
    ### üìå Descripci√≥n:
    
    Zonas de aparici√≥n de h√©roes y escuadras. Definidas por el equipo en la fase de preparaci√≥n.
    
    ### üß© Componentes:
    
    - `SpawnPointComponent`:
        - `teamID`: int
        - `spawnID`: int
        - `position`: `float3`
    - `RespawnSystem`:
        - Cuando un h√©roe muere, se activa un cooldown.
        - Al terminar el cooldown, reaparece en su punto designado.
    - `SpawnSelectionSystem` (en fase previa al combate):
        - Permite al jugador seleccionar el spawn inicial desde UI

## ‚öîÔ∏è 5. Sistema de Combate y Da√±o

---

### üßç 5.1 Combate del H√©roe (Colliders y Animaciones)

üìå **Descripci√≥n:**

El h√©roe combate en tercera persona mediante **ataques animados y habilidades**, ejecutados con colliders sincronizados con la animaci√≥n. Cada **clase de arma** (espada + escudo, lanza, etc.) tiene su propio set de animaciones y habilidades.

Las acciones ofensivas consumen **stamina**, tienen **cooldown**, y son definidas desde el **loadout**.

üß© **Componentes clave:**

```csharp
HeroCombatComponent (IComponentData)
- activeWeapon: Entity
- currentStamina: float
- attackCooldown: float
- abilityPrimary: Entity (Q)
- abilitySecondary: Entity (E)
- ultimateAbility: Entity (R)
- isAttacking: bool
```

```csharp
HeroStaminaSystem
- Reduce stamina al atacar, correr, esquivar, usar habilidad
- Recupera stamina fuera de combate
```

```csharp
HeroAttackSystem
- Escucha input
- Valida cooldown y stamina
- Reproduce animaci√≥n correcta
- Activa collider de arma mediante Animation Events
- Genera golpes cr√≠ticos con multiplicador 1.5x seg√∫n `criticalChance` del arma
```

```csharp
WeaponColliderAuthoring (MonoBehaviour ‚Üí Baker)
- Maneja habilitaci√≥n/deshabilitaci√≥n de PhysicsShape
- Se activa desde la animaci√≥n (frame exacto)
```

üîÅ **Interacci√≥n:**

- Requiere sistema de input (HeroInputSystem)
- Sincroniza con `DamageSystem` para aplicar da√±o
- Enlazado al HUD (barra de stamina, cooldowns de habilidades)
- Coordina con el sistema de animaciones por clase (`HeroAnimationStateSystem`)

---

### ü™ñ 5.2 Combate de Escuadras (Detecci√≥n y Ataques Sincronizados)

üìå **Descripci√≥n:**

Las escuadras atacan como **entidad colectiva**. Las unidades detectan enemigos en su rango de ataque, y ejecutan ataques por intervalos. El da√±o se calcula por **unidad**, pero la ejecuci√≥n es **coordinada desde el squad**.

üß© **Componentes clave:**

```csharp
SquadCombatComponent (IComponentData)
- attackRange: float
- attackInterval: float
- attackTimer: float
- targetEntities: DynamicBuffer<Entity>
```

```csharp
UnitWeaponComponent (IComponentData)
- damageProfile: Entity (referencia a ScriptableObject con da√±o, tipo, penetraci√≥n)
- criticalChance: float (probabilidad de cr√≠tico para h√©roe y unidades)
```

```csharp
SquadAttackSystem
- Escanea enemigos dentro del rango
- Selecciona objetivos por unidad
- Ejecuta da√±o cada `attackInterval`
- Sincroniza animaciones por unidad (opcional)
```

üìå **Sincronizaci√≥n y simplificaci√≥n MVP:**

- El MVP usar√° **ataques por intervalo y animaciones gen√©ricas**.
- A futuro, se puede migrar a colisiones reales por unidad.

---

### ‚öîÔ∏è 5.3 Tipos de Da√±o y Resistencias

üìå **Descripci√≥n:**

Todo da√±o en el juego es de tipo:

- `Blunt` (Contundente)
- `Slashing` (Cortante)
- `Piercing` (Perforante)

Cada unidad tiene defensas diferenciadas por tipo y los ataques tienen **penetraciones espec√≠ficas** que ignoran parte de esa defensa.

üß© **Componentes:**

```csharp
csharp
CopiarEditar
enum DamageType { Blunt, Slashing, Piercing }

enum DamageCategory { Normal, Critical, Ability }

`DamageCategory` define la representaci√≥n visual del da√±o. El valor
`Critical` aplica un multiplicador de **1.5x** y se muestra con un popup
mayor y color distinto. `Ability` corresponde a efectos como sangrado y
usa su propio color.

DamageProfile (ScriptableObject)
- baseDamage: float
- damageType: DamageType
- penetration: float

```

```csharp
csharp
CopiarEditar
DefenseComponent (IComponentData)
- bluntDefense: float
- slashDefense: float
- pierceDefense: float

```

```csharp
csharp
CopiarEditar
PenetrationComponent (IComponentData)
- bluntPenetration: float
- slashPenetration: float
- piercePenetration: float

```

üîÅ **Interacci√≥n:**

- Le√≠dos por `DamageCalculationSystem` cuando un ataque impacta.
- El tipo de da√±o determina qu√© defensa y qu√© penetraci√≥n se aplican.

---

### üßÆ 5.4 C√°lculo de Da√±o y Penetraci√≥n (L√≥gica en C#)

üìå **F√≥rmula b√°sica de c√°lculo:**

```csharp
float CalculateEffectiveDamage(float baseDamage, float defense, float penetration)
{
    float mitigatedDefense = Mathf.Max(0, defense - penetration);
    return Mathf.Max(0, baseDamage - mitigatedDefense);
}
```

üß© **Sistemas involucrados:**

```csharp
DamageCalculationSystem
- Lee DamageProfile, DefenseComponent y PenetrationComponent
- Aplica da√±o resultante a HealthComponent
 - Aplica multiplicador 1.5f si el `DamageCategory` es `Critical`

HealthComponent (IComponentData)
- maxHealth: float
- currentHealth: float
```

- Si `currentHealth <= 0`, se notifica a `DeathSystem`
- Puede desencadenar animaci√≥n de muerte, retirada de unidad, etc.

---

### ‚è±Ô∏è 5.5 Gesti√≥n de Cooldowns y Tiempos de Habilidad

üìå **Descripci√≥n:**

Cada habilidad equipada tiene su **cooldown individual**, que se reduce con el tiempo. Si no hay stamina suficiente, no se puede usar.

üß© **Componentes:**

```csharp
CooldownComponent (IComponentData)
- cooldownDuration: float
- currentCooldown: float
- isReady: bool
```

```csharp
HeroAbilityComponent (IComponentData)
- referencia al ScriptableObject de habilidad activa
- staminaCost: float
- cooldownComponent: Entity
```

```csharp
CooldownSystem
- Reduce `currentCooldown` cada frame
- Marca `isReady = true` cuando cooldown llega a 0
```

üîÅ **Integraci√≥n:**

- `HeroInputSystem` detecta el input y consulta `HeroAbilityComponent`
- Si hay stamina y cooldown listo, se activa la habilidad
- El HUD debe mostrar:
    - Icono gris ‚Üí en cooldown
    - N√∫meros ‚Üí segundos restantes
    - Animaci√≥n de ‚Äúcooldown completado‚Äù

---

## üîÑ 6. Flujo de Partida

---

### üß≠ 6.1 Transiciones entre Escenas

*(Feudo ‚Üí Preparaci√≥n ‚Üí Combate ‚Üí Post Batalla)*

üìå **Descripci√≥n:**

El juego est√° dividido en **escenas independientes** que representan los diferentes estados de juego. Cada transici√≥n debe manejarse limpiamente para conservar los datos del jugador (loadouts, perks, escuadras seleccionadas).

üß© **Elementos a implementar:**

```csharp
SceneFlowManager (Singleton)
- Estado actual del juego: enum {Feudo, Preparaci√≥n, Combate, PostPartida}
- Carga as√≠ncrona de escenas usando Addressables
- Persiste datos del jugador entre escenas (DataContainer)
```

```csharp
DataContainer (ScriptableObject o Singleton en DontDestroyOnLoad)
- Clase del h√©roe seleccionada
- Escuadras activas
- Configuraci√≥n de perks y loadout
```

üîÅ **Interacci√≥n:**

- Carga previa (`Feudo`) permite elegir escuadras y perks
- En combate, los datos del `DataContainer` son le√≠dos por los sistemas de spawning e inicializaci√≥n
- Post batalla lee datos de rendimiento para recompensas

---

### ‚ò†Ô∏è 6.2 Ciclo de Vida del H√©roe (Muerte, Respawn, Cooldown)

üìå **Descripci√≥n:**

Cuando el h√©roe muere, entra en un estado de cooldown creciente. Durante ese tiempo, la c√°mara se convierte en **modo espectador** y la escuadra entra en estado pasivo.

üß© **Componentes clave:**

```csharp
HeroLifeComponent
- isAlive: bool
- respawnCooldown: float
- deathTimer: float
- deathsCount: int
```

```csharp
HeroRespawnSystem
- Al morir, activa `deathTimer = base + (deathCount √ó incremento)`
- Cuenta atr√°s hasta llegar a 0
- Ejecuta el respawn en punto seleccionado

HeroSpectatorCameraSystem
- Reemplaza c√°mara por seguimiento de aliados vivos
- Navegaci√≥n con ‚Üê / ‚Üí o Tab
```

üîÅ **Interacci√≥n:**

- `HUDSystem` cambia a modo espectador (UI reducida)
- La `HeroSpawnManager` debe acceder a spawn points v√°lidos

---

### ü™ñ 6.3 Estado y Retiro de Escuadra al Morir el H√©roe

üìå **Descripci√≥n:**

La escuadra que ten√≠a el h√©roe queda **manteniendo posici√≥n** al morir el jugador. Al faltar 10 segundos para que el h√©roe reviva, la escuadra inicia su **retirada inteligente** y desaparece despu√©s de 5 segundos si no muere antes.

üß© **Componentes:**

```csharp
SquadStateComponent
- currentState: enum {Activo, Defendiendo, Retirada, Desaparecida}
- lastOwnerAlive: bool
- retreatTriggered: bool
```

```csharp
SquadRetreatSystem
- Espera `respawnTime - 10s`
- Busca ruta con menor presencia enemiga (usando mapa de calor o navmesh tags)
- Cambia estado ‚Üí Retirada
- Desactiva escuadra si llega a punto seguro o tras 5s

SquadVisibilitySystem
- Maneja fade-out visual si se retira correctamente
```

üîÅ **Interacci√≥n:**

- `NavMeshSystem` o un sistema de evasi√≥n ser√° necesario para evitar zonas hostiles
- `HUD` puede marcar el estado de la escuadra (p.ej., √≠cono de retirada)

---

### üè≥Ô∏è 6.4 Reglas del Sistema de Captura y Uso de Supply Points

üìå **Descripci√≥n:**

Los supply points permiten al jugador **curar** su escuadra y cambiar su loadout solo si no est√°n **en disputa**. Los puntos tienen 3 estados: aliado, neutral y enemigo.

üß© **Componentes:**

```csharp
SupplyPointComponent
- ownerTeam: enum {None, TeamA, TeamB}
- isContested: bool
- captureProgress: float
- healingRadius: float
```

```csharp
SupplyCaptureSystem
- Detecta h√©roes enemigos en zona sin defensores
- Inicia barra de captura
- Interrumpe captura si entra defensor
- Al capturar, cambia `ownerTeam`

SupplyInteractionSystem
- Si supply est√° en estado aliado y sin disputa:
    - Permite cambiar escuadra activa
    - Cura pasivamente a h√©roe y escuadra en √°rea
```

üîÅ **Interacci√≥n:**

- Se conecta con `HeroInputSystem` (para men√∫ de cambio)
- `HUD` muestra progreso de captura si el jugador est√° en rango

---

### üìç 6.5 Asignaci√≥n de Spawn Inicial

üìå **Descripci√≥n:**

En la pantalla de preparaci√≥n, el jugador elige un **punto de spawn** entre los disponibles. Este se usa al inicio y tambi√©n en sus respawns durante la partida.

üß© **Componentes:**

```csharp
SpawnPointComponent
- team: Team
- isActive: bool
- position: Vector3
```

```csharp
SpawnSelectionSystem
- Interfaz que muestra puntos v√°lidos en el mapa
- Permite elegir uno antes de iniciar partida

HeroSpawnSystem
- Spawnea al h√©roe en el punto elegido
- Lo reutiliza para futuros respawns
```

üîÅ **Interacci√≥n:**

- `MapUIController` para seleccionar spawn
- `GameManager` o `MatchController` asigna posici√≥n real al iniciar partida

## üß¨ 7. Progresi√≥n y Guardado de Datos

---

### üß† 7.1 Progresi√≥n del H√©roe (Nivel, Atributos, Perks)

üìå **Descripci√≥n:**

El h√©roe puede subir del **nivel 1 al 30**. Cada nivel otorga puntos para mejorar sus atributos base (`Fuerza`, `Destreza`, `Armadura`, `Vitalidad`) y puntos para desbloquear perks activos o pasivos.

üß© **Componentes:**

```csharp
HeroProgressComponent
- level: int
- currentXP: float
- xpToNextLevel: float
- attributePoints: int
- perkPoints: int
```

```csharp
HeroAttributesComponent
- fuerza: int
- destreza: int
- armadura: int
- vitalidad: int
```

```csharp
HeroLevelSystem
- Al finalizar partida, a√±ade XP basada en rendimiento
- Si supera `xpToNextLevel`, sube de nivel
- Asigna nuevos puntos de atributo y perk
```

üîÅ **Interacci√≥n:**

- Con `HUDSystem` para mostrar nivel, barra de XP y atributos
- Con `PerkSystem` para validar puntos disponibles

---

### üíæ 7.2 Guardado Local en MVP

üìå **Descripci√≥n:**

Toda la progresi√≥n del jugador en MVP se guarda **localmente**. Esto incluye:

- Nivel y atributos del h√©roe
- Perks desbloqueados
- Escuadras formadas y su progreso

üß© **Componentes:**

```csharp
SaveData (clase serializable)
- HeroData: nivel, atributos, perks activos
- SquadData: lista de escuadras, nivel, habilidades
- UserSettings: configuraci√≥n de audio, UI, etc.
```

```csharp
LocalSaveSystem
- Guardar en `Application.persistentDataPath`
- Serializaci√≥n con JSON o BinaryFormatter
- M√©todos: SaveGame(), LoadGame(), ResetProgress()
```

üîÅ **Interacci√≥n:**

- Se ejecuta autom√°ticamente al cerrar o al terminar una partida
- El `Barrac√≥n` y el `Feudo` cargan la data al iniciar escena

---

### üìÅ 7.3 Estructura de ScriptableObjects para Perks y Escuadras

üìå **Descripci√≥n:**

Los perks y escuadras estar√°n definidos como **ScriptableObjects**, facilitando su edici√≥n y expansi√≥n sin tocar c√≥digo.

üß© **Ejemplos:**

```csharp
[CreateAssetMenu(menuName = "Perks/PerkData")]
public class PerkData : ScriptableObject {
    public string perkName;
    public Sprite icon;
    public string description;
    public PerkType type; // Activo / Pasivo
    public List<string> tags; // Ofensivo, Defensa, Liderazgo, Clase
    public float cooldown;
    public EffectData effect;
}
```

```csharp
[CreateAssetMenu(menuName = "Squad/SquadData")]
public class SquadData : ScriptableObject {
    public string squadName;
    public int liderazgoCost;
    public GameObject prefab;
    public List<FormationType> availableFormations;
    public List<AbilityData> abilities;
    public SquadStats baseStats;
}
```

üîÅ **Interacci√≥n:**

- Se usan para poblar la UI en el barrac√≥n y en la pantalla de selecci√≥n
- `CombatSystems` los leen para aplicar sus efectos

---

### üß† 7.4 Sistema de Perks: Carga, Activaci√≥n y Visualizaci√≥n

üìå **Descripci√≥n:**

El sistema de perks es un **√°rbol modular**. El jugador puede activar hasta `5 pasivos` y `2 activos`. Se cargan desde ScriptableObjects y aplican efectos en combate o fuera de √©l.

üß© **Componentes:**

```csharp
PerkComponent
- List<PerkData> activePerks
- List<PerkData> passivePerks
```

```csharp
PerkSystem
- Eval√∫a perks activos cada frame (si est√°n disponibles)
- Ejecuta efecto correspondiente (buff, da√±o, control)
- Verifica requisitos como cooldown y stamina

PerkManager (UI)
- Muestra √°rbol completo de perks disponibles
- Permite asignar y quitar perks con drag & drop o click
```

üìå **Activaci√≥n en Combate:**

- Perks activos est√°n ligados a teclas (`Q`, `E`)
- Consumen stamina y entran en cooldown

üìå **Sinergia:**

- Perks pasivos modifican atributos del h√©roe o su escuadra
- Algunos perks se activan autom√°ticamente seg√∫n condiciones (ej. ‚Äú+mitigaci√≥n si no te mueves‚Äù)

üîÅ **Interacci√≥n:**

- `CombatSystem` accede a buffs de perks en tiempo real
- `SquadSystem` consulta perks que afectan estad√≠sticas o comportamiento
- `HUD` representa el estado de cada perk con √≠conos, cooldown, y tooltips

---

## üåê 8. Multijugador (MVP)

---

### üñß 8.1 Arquitectura de Red: Servidor Dedicado

üìå **Descripci√≥n:**

El MVP funcionar√° sobre **servidores dedicados**, usando **Netcode for GameObjects** (Unity) combinado con **Unity DOTS (ECS)** para la l√≥gica principal.

üß© **Componentes de red:**

- `NetworkManager`: controla el ciclo de conexi√≥n, matchmaking (inicialmente aleatorio), sincronizaci√≥n y desconexiones.
- `ServerGameLoop`: mantiene la l√≥gica central de la partida (captura, puntos, respawn).
- `ClientPredictionSystem`: gestiona predicci√≥n local para control suave del h√©roe.
- `Authority`: el servidor tiene autoridad sobre escuadras, muerte, respawn y puntos de control.

üîÅ **Interacci√≥n:**

- `MatchmakingScene` conecta el jugador con un lobby preasignado.
- El cliente solo ejecuta predicci√≥n visual y env√≠a inputs.
- La validaci√≥n (impactos, cooldowns, cambios de escuadra) se hace en el servidor.

---

### üîÑ 8.2 Sincronizaci√≥n de Escuadras y H√©roes (Snapshots o Comandos)

üìå **Decisi√≥n Final:**

Usaremos **comandos + snapshots ligeros**:

- Comandos: para enviar inputs (ataques, habilidades, √≥rdenes de escuadra)
- Snapshots: para sincronizar estado de unidades, formaciones, vida, posici√≥n, animaciones

üß© **Componentes:**

```csharp
HeroCommandSender (Client)
- Env√≠a input de movimiento, ataque y habilidades

HeroSnapshot (Server ‚Üí Client)
- posici√≥n, rotaci√≥n, animaci√≥n, vida

SquadSnapshot
- posici√≥n promedio de escuadra
- formaci√≥n activa
- n√∫mero de unidades vivas
- habilidades en cooldown
```

üìå **L√≥gica:**

- El servidor mantiene el estado maestro y env√≠a snapshots cada `X` ms.
- Las escuadras son **no controlables directamente** desde el cliente: s√≥lo se env√≠a el tipo de orden (seguir, atacar, mantener).

---

### üö∂ 8.3 Interpolaci√≥n de Movimiento y Predicci√≥n

üìå **Descripci√≥n:**

Para suavizar movimiento y reducir lag visual, se usar√° interpolaci√≥n en h√©roes enemigos y predicci√≥n en el h√©roe local.

üß© **Sistemas:**

- `HeroPredictionSystem`: aplica input local mientras llega confirmaci√≥n del servidor.
- `HeroReconciliationSystem`: corrige discrepancias.
- `SquadInterpolationSystem`: mueve escuadras remotas con suavidad seg√∫n snapshot.
- `NetworkTransformECS`: se usar√° el paquete de Unity adaptado a DOTS.

üìå **Predicci√≥n para habilidades:**

- El HUD mostrar√° uso inmediato.
- Si el servidor cancela el cast (por falta de stamina o interrupci√≥n), se corrige visualmente.

---

### üí¨ 8.4 Comunicaci√≥n entre Jugadores (Chat B√°sico)

üìå **Descripci√≥n:**

Un sistema de chat b√°sico tipo consola permitir√° mensajes entre jugadores del mismo equipo durante la partida.

üß© **Componentes:**

```csharp
ChatMessageComponent
- senderName: string
- message: string
- teamOnly: bool
```

```csharp
ChatSystem
- Escucha input en UI (tecla `Enter`)
- Env√≠a mensaje al servidor
- El servidor reenv√≠a a todos los clientes del equipo
```

üìå **UI:**

- Consola desplegable con historial (toggle con `T`)
- Campo de texto para escribir
- Color seg√∫n tipo de mensaje (equipo, global en lobby, sistema)

---

### üîÑ 8.5 Cambios de Escuadra desde Supply Points (Restricciones de Sincronizaci√≥n)

üìå **Descripci√≥n:**

El h√©roe puede cambiar su escuadra **√∫nicamente en supply points seguros**. Esta acci√≥n debe ser **validada por el servidor** y sincronizada con todos los jugadores.

üß© **Proceso de cambio:**

1. Cliente solicita cambio (con ID de escuadra deseada)
2. El servidor valida:
    - Que el h√©roe est√° en un supply point aliado
    - Que no hay enemigos en rango del punto
    - Que tiene esa escuadra en su loadout
    - Que tiene suficiente liderazgo
3. El servidor despawnea la escuadra actual y spawnea la nueva
4. Se env√≠a `SquadChangeEvent` a todos los clientes

üß© **Componentes:**

```csharp
SupplyPointComponent
- ownerTeam: enum
- isContested: bool
- healingEnabled: bool
SquadSwapRequest (Command)
- newSquadId: int
```

```csharp
- SquadSwapSystem (Server-side)
   - Valida condiciones
   - Ejecuta el cambio
   - Dispara eventos de sincronizaci√≥n
```

üîÅ **Interacci√≥n:**

- El HUD activa la UI de escuadras disponibles cuando se entra en un supply point v√°lido
- El cambio puede tardar unos segundos e interrumpirse si el punto es contestado

---

## üñ•Ô∏è 9. UI y HUD

---

### üß± 9.1 Sistema de UI (Canvas con Unity UI)

üìå **Descripci√≥n:**

Toda la interfaz se desarrollar√° con **Unity UI (Canvas)** en modo **Screen Space - Overlay**. Los elementos se organizar√°n en prefabs reutilizables seg√∫n contexto (feudo, batalla, selecci√≥n de escuadra, HUD).

üß© **Elementos clave:**

- `UIManager`: sistema principal que activa/desactiva m√≥dulos de UI seg√∫n la escena o estado del juego.
- `UIScreenController`: prefabs individuales (HUD, Escuadras, Loadout, PostBattle) conectados al `UIManager`.
- `UIBinderComponent`: vincula entidades ECS con elementos UI (por ejemplo, vida de escuadra, cooldown de habilidad).
- `UIDocumentRoot` (UI Toolkit opcional en futuro MVP ampliado).

üîÅ **Interacci√≥n:**

- Se comunica con `GameStateSystem` para activar interfaces por fase de partida.
- Lee datos de `HUDDataComponent`, `CooldownComponent`, `SquadStatusComponent`.

---

### ü©∏ 9.2 HUD de Batalla

üìå **Descripci√≥n:**

El HUD est√° dise√±ado para ser minimalista pero funcional, inspirado en *Conqueror‚Äôs Blade*. Muestra datos relevantes del h√©roe, su escuadra y el entorno.

üß© **Elementos del HUD:**

- **Barra de salud del h√©roe** (`HeroHealthBar`)
- **Barra de estamina** (`HeroStaminaBar`)
- **Iconos de habilidades** con cooldown (`AbilityHUDSlot`)
- **Escuadra activa**:
    - N√∫mero de unidades restantes
    - Formaci√≥n actual
    - √ìrdenes activas
    - Iconos de habilidades de escuadra
- **Minimapa**
- **Feedback de captura de bandera**
- **Feedback de supply point**

üß© **Componentes:**

- `HUDController`: actualiza la informaci√≥n cada frame.
- `HeroStatusComponent`, `SquadStatusComponent`, `CooldownComponent`, `CaptureProgressComponent`.

üîÅ **Sincronizaci√≥n:**

- Datos del h√©roe y escuadra se extraen del ECS world del jugador local.
- Elementos con animaci√≥n (CD circular, da√±o recibido) actualizados por eventos visuales.

---

### üó∫Ô∏è 9.3 Minimapa Din√°mico (Feudo y Combate)

üìå **Descripci√≥n:**

Minimapa en tiempo real que muestra aliados, enemigos, puntos de captura y supply points.

üß© **Sistemas involucrados:**

- `MinimapCamera`: c√°mara ortogr√°fica en altura sobre el mapa.
- `MinimapRenderer`: proyecta √≠conos en UI seg√∫n la posici√≥n de entidades con `MinimapIconComponent`.

üß© **Iconos Renderizados:**

- H√©roes (propios y enemigos)
- Escuadras activas
- Puntos de captura (A, Base)
- Supply points (con colores seg√∫n estado: azul/rojo/gris)
- Objetivos activos (marcadores)

üîÅ **Interacci√≥n:**

- En feudo muestra NPCs y zonas del hub.
- En batalla sincroniza con `GameStateSystem` para marcar objetivos activos.

---

### üß∞ 9.4 Interfaz de Preparaci√≥n y Loadouts

üìå **Descripci√≥n:**

Pantalla accesible **antes de entrar a batalla**, permite seleccionar:

- Clase (arma)
- Escuadras (seg√∫n liderazgo disponible)
- Perks activos/pasivos
- Formaciones predefinidas

üß© **Componentes:**

- `LoadoutBuilderUI`: permite arrastrar y soltar escuadras en slots seg√∫n liderazgo restante.
- `HeroPreviewWidget`: muestra el h√©roe en 3D con equipamiento activo.
- `PerkTreeUI`: √°rbol de perks simple con activaci√≥n y reset.

üîÅ **L√≥gica interna:**

- Valida que el total de liderazgo no se exceda.
- Guarda preferencias en `LoadoutSaveData`.
- Se comunica con `GameBootstrapSystem` al iniciar la batalla.

---

### ‚öôÔ∏è 9.5 Men√∫s de Interacci√≥n con Supply y Puntos de Captura

üìå **Supply Point UI:**

- Se activa al **entrar en rango de un supply point aliado y no contestado**.
- Muestra:
    - Iconos de escuadras disponibles (dentro del loadout)
    - Bot√≥n para cambiar escuadra activa
    - Mensaje de curaci√≥n pasiva si aplica
- Usa `SupplyPointUIController`, que escucha `SupplyInteractionComponent`.

üìå **Puntos de Captura UI:**

- Aparece cuando el h√©roe entra al radio de una bandera.
- Muestra:
    - Barra de progreso de captura
    - Indicador de bloqueo si hay enemigos presentes
    - Nombre del punto (A, Base)
- Usa `CapturePointUIController` + `CaptureProgressComponent`.

üîÅ **Actualizaci√≥n:**

- Ambas interfaces est√°n sincronizadas con datos del servidor.
- La visibilidad de estas UIs depende de `ZoneDetectionSystem` que activa/desactiva componentes de UI seg√∫n el rango.

---

## üîê 10. Seguridad y Backend (Para expansi√≥n futura)

---

### üü° 10.1 Estado actual (Solo Local ‚Äì MVP)

üìå **Descripci√≥n:**

Durante el MVP, todo el progreso del jugador (atributos, perks, escuadras, loadouts, etc.) se almacena **en archivos locales en disco**. No hay necesidad de conexi√≥n a servidores ni validaci√≥n en red.

üß© **Componentes clave:**

- `SaveManager`: sistema central encargado de leer/escribir archivos de progreso.
- `PlayerProgressData` (Scriptable/Serializable):
    - nivel
    - puntos de atributo asignados
    - perks desbloqueados
    - escuadras desbloqueadas
    - configuraciones de loadout
- `SaveSystem` (C#):
    - Guarda y carga archivos `.json` en `Application.persistentDataPath`.
    - Funciones: `SaveProgress()`, `LoadProgress()`, `ResetProgress()`.

üîÅ **Interacci√≥n:**

- `SaveManager` se activa en:
    - Inicio del juego (carga datos)
    - Fin de partida (guarda experiencia, nivel, perks)
    - Men√∫s de loadout/perks/escuadras (guarda al confirmar cambios)
- Integrado con `GameBootstrapSystem` y `BarrackSystem`.

üîí **Consideraciones:**

- **No hay validaci√≥n de integridad ni anti-trampa.**
- Datos pueden ser modificados por el usuario (f√°cilmente).
- La l√≥gica del juego conf√≠a completamente en los datos locales durante el MVP.

---

### üì¶ 10.2 Recomendaciones para transici√≥n a Backend (Post-MVP)

üìå **Transici√≥n sugerida:**

Para una futura versi√≥n multijugador completa, el backend deber√° gestionar:

- Login y autenticaci√≥n (OAuth, JWT, etc.)
- Almacenamiento de progresi√≥n del jugador (niveles, perks, squads)
- Emparejamiento (matchmaking) en partidas PVP
- Validaci√≥n de partidas, resultados y econom√≠a

üß© **Servicios recomendados:**

| Necesidad | Recomendaci√≥n |
| --- | --- |
| Backend general | [PlayFab](https://playfab.com/), [Firebase](https://firebase.google.com/), [GameLift] (AWS) |
| Login | Email + password / OAuth (Google/Steam) |
| Matchmaking | PlayFab Matchmaking, Photon Fusion, Unity Lobby |
| Progresi√≥n remota | Cloud Save con sincronizaci√≥n en login |
| Anti-cheat | Unity Client Authority con validaci√≥n parcial en servidor |

üß© **Migraci√≥n futura del sistema local:**

- `SaveManager` debe tener una **interfaz abstracta (`ISaveProvider`)** con implementaciones:
    - `LocalSaveProvider`
    - `CloudSaveProvider`

Esto permite migrar el sistema sin alterar el resto del c√≥digo.

---

### üîê 10.3 Gesti√≥n Segura de Progresi√≥n (futuro)

üìå **Progresi√≥n segura implica:**

- Evitar que usuarios alteren su progreso fuera del juego.
- Validar toda modificaci√≥n de datos desde el servidor.
- Detectar comportamientos an√≥malos (ej. subir 5 niveles de golpe).

üß© **Recomendaciones:**

- Uso de tokens por sesi√≥n.
- Validaci√≥n del progreso contra l√≠mites razonables (anticheat b√°sico).
- Logs de acciones del jugador para revisi√≥n en caso de errores o abuso.
- Evitar usar PlayerPrefs para datos cr√≠ticos, incluso en MVP.

---

‚úÖ **Resumen para el MVP:**

- Solo datos locales (JSON).
- No se usa backend real.
- No hay autenticaci√≥n.
- Se deja abierta la arquitectura para expansi√≥n con `ISaveProvider`.

---

## ‚öôÔ∏è 11. Extras T√©cnicos

---

### üéñÔ∏è 11.1 Sistema de Liderazgo (Restricciones en Loadouts)

üìå **Descripci√≥n:**

Cada escuadra tiene un coste de liderazgo (1‚Äì3 puntos). El h√©roe tiene un valor base que limita cu√°ntas escuadras puede llevar activas en su loadout. Este sistema restringe combinaciones y promueve decisiones t√°cticas.

üß© **Componentes clave:**

- `HeroLeadershipComponent`:
    - `currentLeadership: int`
    - `maxLeadership: int`
- `SquadMetadata` (ScriptableObject):
    - `leadershipCost: int`
- `LoadoutSystem`:
    - Valida el total de liderazgo al seleccionar escuadras.
    - Previene guardar loadouts que excedan el l√≠mite.

üîÅ **Interacci√≥n:**

- La UI de preparaci√≥n de batalla muestra el total usado vs m√°ximo.
- Se comunica con el sistema de selecci√≥n de escuadras y perks (algunos perks aumentan `maxLeadership`).

---

### üí® 11.2 Sistema de Estamina y Gasto por Acci√≥n

üìå **Descripci√≥n:**

El h√©roe utiliza estamina al ejecutar ataques, sprints y habilidades. La estamina se regenera fuera de combate. Cada acci√≥n tiene un coste definido.

üß© **Componentes clave:**

- `StaminaComponent`:
    - `currentStamina: float`
    - `maxStamina: float`
    - `regenRate: float`
- `HeroStaminaSystem`:
    - Reduce `currentStamina` seg√∫n acci√≥n (sprint, ataque, habilidad).
    - Impide acciones si no hay suficiente estamina.
    - Regenera estamina si el jugador no act√∫a ofensivamente por cierto tiempo.
- `StaminaUsageProfile` (ScriptableObject):
    - Define cu√°nto cuesta cada tipo de acci√≥n por clase.

üîÅ **Interacci√≥n:**

- Integrado con `HeroInputSystem`, `CombatSystem`, `AbilitySystem`.
- El HUD muestra barra de estamina y grises cuando est√° agotada.
- `CooldownSystem` y `StaminaSystem` deben estar sincronizados.

---

### üß± 11.3 Visualizaci√≥n de Formaciones y Selecci√≥n de Unidades

üìå **Descripci√≥n:**

Formaciones afectan el comportamiento y disposici√≥n espacial de las unidades. Deben poder activarse por hotkeys (`F1`, `F2`, etc.) o UI, y verse claramente en el terreno.

üß© **Componentes clave:**

- `FormationComponent`:
    - `currentFormation: enum {Line, Dispersed, Testudo, Schiltron}`
    - `formationPattern: Vector3[]`
- `FormationSystem`:
    - Calcula las posiciones relativas de cada unidad seg√∫n la formaci√≥n activa.
    - Reorganiza el `LocalToWorld` de cada unidad cuando se cambia de formaci√≥n.
- `FormationVisualizer` (MonoBehaviour):
    - Renderiza √≠conos, siluetas o l√≠neas gu√≠a sobre el terreno.
    - Usado en modo t√°ctico ligero (ALT) o al apuntar orden.

üîÅ **Interacci√≥n:**

- Coordina con `SquadCommandSystem` (para aplicar la orden).
- La UI muestra formaciones disponibles para la escuadra activa.
- Respeta obst√°culos del terreno (usando NavMesh o RaycastDown).

---

### üß† 11.4 Optimizaci√≥n de Escena y Assets (Nivel MVP)

üìå **Descripci√≥n:**

Para asegurar buen rendimiento durante el MVP, se aplican pr√°cticas b√°sicas de optimizaci√≥n de escena y contenido.

üß© **Pr√°cticas aplicadas:**

- `GPU Instancing` en materiales de escuadras.
- `LOD Groups` para modelos 3D complejos (murallas, torres).
- `Occlusion Culling` en el mapa de combate.
- `Texture Atlas` para unidades que comparten materiales.
- `NavMesh` bakeado por zonas (NavMesh Surface segmentado).

üß© **Componentes recomendados:**

- `PerformanceTrackerSystem` (opcional): muestra FPS, draw calls y GC.
- `ObjectPoolSystem`: para proyectiles, habilidades y unidades temporales.
- `AsyncSceneLoader`: para evitar stutter al cambiar de escena.

üîÅ **Interacci√≥n:**

- Directa con el sistema de renderizado y entidades de combate.
- Las formaciones, visualizadores y AI deben usar `EntityCommandBuffer` para optimizar instanciaci√≥n y destrucci√≥n.

---

## üìò 12. Glosario T√©cnico (TDD)

> Este glosario resume los principales conceptos t√©cnicos y arquitect√≥nicos usados en la implementaci√≥n del juego.
> 

---

### üîß Sistemas / Componentes

| T√©rmino | Descripci√≥n |
| --- | --- |
| **ECS (Entity Component System)** | Paradigma de programaci√≥n basado en datos. Separa datos (`ComponentData`) de l√≥gica (`SystemBase`). Optimiza rendimiento y escalabilidad en Unity DOTS. |
| **Netcode for GameObjects (Unity)** | Framework oficial para sincronizaci√≥n en red. Soporta sincronizaci√≥n de transform, RPCs y predicci√≥n. Utilizado para el MVP. |
| **ScriptableObject** | Objeto serializable de Unity usado para definir data externa editable por dise√±ador (perks, escuadras, atributos, etc.). |
| **FSM (Finite State Machine)** | M√°quina de estados para controlar la l√≥gica de flujo del h√©roe o escuadras (ej: `Idle` ‚Üí `Combate` ‚Üí `Retirada`). |
| **DynamicBuffer** | Buffer din√°mico de datos dentro de una entidad ECS. √ötil para almacenar m√∫ltiples objetivos, comandos o historial de √≥rdenes. |

---

### ‚öîÔ∏è Combate y Movimiento

| T√©rmino | Descripci√≥n |
| --- | --- |
| **DamageType** | Enum que representa el tipo de da√±o: `Contundente`, `Cortante`, `Perforante`. Usado en c√°lculos de da√±o. |
| **Penetration** | Valor que reduce la defensa del enemigo antes de aplicar da√±o. Definida por tipo de da√±o. |
| **FormationSystem** | Sistema que reordena posiciones de unidades dentro de una escuadra seg√∫n una formaci√≥n seleccionada. Usa `NavMesh` + `LocalToWorld`. |
| **StaminaSystem** | Controla el gasto y recuperaci√≥n de estamina en el h√©roe. Interact√∫a con input, habilidades y UI. |
| **AbilityComponent** | Define datos de una habilidad (da√±o, tipo, coste de stamina, cooldown) y su ejecuci√≥n. |

---

### üß† Escuadras e IA

| T√©rmino | Descripci√≥n |
| --- | --- |
| **SquadComponent** | Identifica una entidad como escuadra. Almacena formaci√≥n activa, estado y referencia a unidades. |
| **UnitGroupAI** | L√≥gica que coordina el comportamiento grupal de unidades: mantenerse juntas, atacar en sincron√≠a, evitar colisiones. |
| **RetreatLogicSystem** | Sistema que activa la retirada autom√°tica de una escuadra cuando el h√©roe est√° muerto. |
| **ZoneTriggerComponent** | Collider de tipo `trigger` para detectar si un h√©roe o escuadra entra en una zona especial (ej: supply point, punto de captura). |

---

### üß± UI y Escenarios

| T√©rmino | Descripci√≥n |
| --- | --- |
| **HUD (Heads-Up Display)** | Superposici√≥n visual durante la partida. Muestra vida, habilidades, estamina, minimapa, escuadra activa. |
| **Loadout** | Conjunto predefinido de arma, perks y escuadras que puede equipar el jugador antes de entrar a combate. Validado por sistema de liderazgo. |
| **Minimapa** | Mapa en tiempo real en UI que muestra puntos de captura, supply points y aliados. Actualizado por sistema de radar/posici√≥n. |
| **SceneLoaderSystem** | Encargado de cargar o descargar escenas Unity (feudo, combate, etc.) de forma as√≠ncrona y sin bloqueos. |
| **FormationVisualizer** | Renderiza l√≠neas o √≠conos en el terreno para indicar la posici√≥n deseada de las unidades. Usa datos de `FormationComponent`. |

---

### üíæ Guardado y Expansi√≥n

| T√©rmino | Descripci√≥n |
| --- | --- |
| **SaveManager** | M√≥dulo que guarda y carga el progreso del jugador desde disco (JSON local para MVP). |
| **ISaveProvider** | Interfaz que permite intercambiar entre guardado local y en nube (ej: para post-MVP). |
| **PlayerProgressData** | Estructura que almacena nivel, perks, escuadras desbloqueadas, loadouts, puntos de atributo. |
| **CloudSave (futuro)** | Alternativa a almacenamiento local, donde los datos son sincronizados con un servidor seguro. |